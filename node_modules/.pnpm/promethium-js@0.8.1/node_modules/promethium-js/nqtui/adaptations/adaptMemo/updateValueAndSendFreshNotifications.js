import observableSubscriptionsCleanup from "../observableSubscriptionsCleanup";
import getCleanupNode from "../getCleanupNode";
import { effectContexts } from "../effectContexts";
import { sendSignals } from "../sendSignals";
//aside from a few caveats, this function basically runs like the execute function of an effect
export function updateValueAndSendFreshNotifications(memo, fn) {
    var _a;
    //set `childCount` back to zero to enable children effects to obtain correct positions upon recreation
    memo.childCount = 0;
    //fire cleanups make sure proceedings go smoothly
    const cleanupSet = (_a = getCleanupNode(memo)) === null || _a === void 0 ? void 0 : _a.get(0);
    cleanupSet === null || cleanupSet === void 0 ? void 0 : cleanupSet.forEach((cleanup) => {
        cleanup();
    });
    cleanupSet === null || cleanupSet === void 0 ? void 0 : cleanupSet.clear();
    //push memo onto context to enable tracking by state and other memos
    effectContexts.push(memo);
    const prevMemoValue = memo.value;
    memo.value = fn(memo.value);
    cleanupSet === null || cleanupSet === void 0 ? void 0 : cleanupSet.add(() => observableSubscriptionsCleanup(memo));
    //remove memo from context to disable tracking by state and other memos
    effectContexts.pop();
    //let subscriptions know that their stale value has been updated so that they can notify and
    //update themselves and their subscriptions if any
    if (Object.is(prevMemoValue, memo.value)) {
        sendSignals(memo, "falseAlarm");
    }
    else {
        sendSignals(memo, "fresh");
    }
}
